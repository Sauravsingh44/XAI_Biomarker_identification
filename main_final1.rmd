
# set directory
```{r}
setwd("D:/upes/sem6/Minor2/Previous work/minorXAI/final_expression_dataset")
getwd()
```
# setting working directory
```{r}
file_path <- "D:/upes/sem6/Minor2/Previous work/minorXAI/final_expression_dataset"

sdrf_location <- read.table("D:/upes/sem6/Minor2/Previous work/minorXAI/final_expression_dataset/E-MEXP-3756.sdrf.txt", header=TRUE, sep="\t")
```

```{r}
# Reading file (M2)
data <- file.path(file_path, "E-MEXP-3756.sdrf.txt")
SDRF <- read.delim(data)
```

```{r}
# Set the directory containing the .CEL files
raw_data_dir <- "D:/upes/sem6/Minor2/Previous work/minorXAI/final_expression_dataset"

if (!requireNamespace("Biobase", quietly = TRUE)) {
  install.packages("BiocManager")
  BiocManager::install("Biobase")
}
library(Biobase)
```

```{r}
#import SDRF file
sdrf_location <- file.path(raw_data_dir,"E-MEXP-3756.sdrf.txt")
SDRF <- read.delim(sdrf_location)
rownames(SDRF) <- SDRF$Array.Data.File
SDRF <- AnnotatedDataFrame(SDRF)

raw_data <- oligo::read.celfiles(filenames = file.path(raw_data_dir,
                                                       SDRF$Array.Data.File),
                                 verbose = FALSE, phenoData = SDRF)
stopifnot(validObject(raw_data))

```

```{r}
##pData Functions##
head(Biobase::pData(raw_data))
names(Biobase::pData(raw_data))
Biobase::pData(raw_data) <- Biobase::pData(raw_data)[,
                   c("Source.Name", "Array.Data.File","Factor.Value.disease.")]

# Qualifying control of the raw data##
Biobase::exprs(raw_data)[1:5,1:5]
exp_raw <- log2(Biobase::exprs(raw_data))
```

```{r}
# Constructing PCA plot of RAW expression data
PCA_raw <-prcomp(t(exp_raw),scale.= FALSE)

percentvar <- round(100*PCA_raw$sdev^2/sum(PCA_raw$sdev^2),1)
sd_ratio <- sqrt(percentvar[2]/percentvar[1])
dataGG <- data.frame(PC1 = PCA_raw$x[,1],PC2 = PCA_raw$x[,2],
                     phenotype=pData(raw_data)$Factor.Value.disease.)
library(ggplot2)

ggplot(dataGG, aes(PC1, PC2)) + 
  geom_point(aes(shape = phenotype, color = phenotype)) + 
  ggtitle("PCA plot of the log-transformed raw expression data") + 
  xlab(paste0("PC1, VarExp: ", percentvar[1], "%")) + 
  ylab(paste0("PC2, VarExp: ", percentvar[2], "%")) + 
  theme(plot.title = element_text(hjust = 0.5)) + 
  coord_fixed(ratio = sd_ratio) + 
  scale_shape_manual(values = c(4, 15)) + 
  scale_color_manual(values = c("red", "blue"))
```


```{r}
# Box plot of the RAW expression data
oligo::boxplot(raw_data,target="core",
               main = "Boxplot of log2-intensities for the raw data")
```

```{r}
#normalization

## RMA calibration of the data (Robust Multi-array Average) (Quantile Normalization) 
palmieri_eset_norm <- oligo::rma(raw_data) 

## PCA plot of the NORMALIZED data 
exp_palmieri <- Biobase::exprs(palmieri_eset_norm) 
PCA <- prcomp(t(exp_palmieri), scale = FALSE) 

## Calculate percentage variance explained by each principal component
percentvar <- round(100 * PCA$sdev^2 / sum(PCA$sdev^2), 1) 

## Compute the standard deviation ratio
sd_ratio <- sqrt(percentvar[2] / percentvar[1])

## Create a data frame for PCA plot
dataGG <- data.frame(
  PC1 = PCA$x[,1], 
  PC2 = PCA$x[,2], 
  phenotype = Biobase::pData(palmieri_eset_norm)$Factor.Value.disease.
)

ggplot(dataGG, aes(PC1, PC2)) + 
  geom_point(aes(shape = phenotype, color = phenotype)) + 
  ggtitle("PCA plot of the calibrated, summarized data") + 
  xlab(paste0("PC1, VarExp: ", percentvar[1], "%")) + 
  ylab(paste0("PC2, VarExp: ", percentvar[2], "%")) + 
  theme(plot.title = element_text(hjust = 0.5)) + 
  coord_fixed(ratio = sd_ratio) + 
  scale_shape_manual(values = c(4, 15)) + 
  scale_color_manual(values = c("red", "blue"))
```

```{r}
# Box plot of the normalized data
oligo::boxplot(palmieri_eset_norm,target="core",
               main = "Boxplot of log2-intensities for the raw data")
```


# Heat map Construction
## HEAT MAP CONSTRUCTION ## 
# Install pheatmap package
# install.packages("pheatmap")

```{r}
# Load necessary libraries
library(stringr) 
library(pheatmap) 
```

```{r}
# Extract row names
row.names(pData(palmieri_eset_norm)) 

# Display phenotype data
pData(palmieri_eset_norm) 

# Create disease group labels
disease_names <- ifelse(
  str_detect(pData(palmieri_eset_norm)$Factor.Value.disease, "normal"), 
  "normal", 
  "colorectal cancer"
)

# Create annotation dataframe for heatmap
annotation_for_heatmap <- data.frame(disease = disease_names) 

# Assign row names
row.names(annotation_for_heatmap) <- row.names(pData(palmieri_eset_norm)) 
```

```{r}
# Display row names (for debugging)
row.names(pData(palmieri_eset_norm)) 
row.names(annotation_for_heatmap) 
```

```{r}
# Compute distance matrix using Manhattan distance
dists <- as.matrix(dist(t(exp_palmieri), method = "manhattan")) 

# Assign row names to distance matrix
rownames(dists) <- row.names(pData(palmieri_eset_norm)) 

# Check row names of the distance matrix
rownames(dists) 
```

```{r}
# Define heatmap color palette
hmcol <- rev(colorRampPalette(RColorBrewer::brewer.pal(9, "YlOrRd"))(255)) 

# Remove column names
colnames(dists) <- NULL 

# Set diagonal values to NA
diag(dists) <- NA 

ann_colors <- list(
  disease = c("normal" = "green", "colorectal cancer" = "red")
)

pheatmap(dists, col = (hmcol), 
         annotation_row = annotation_for_heatmap, 
         annotation_colors = ann_colors, 
         legend = TRUE, 
         treeheight_row = 0, 
         legend_breaks = c(min(dists, na.rm = TRUE), 
                           max(dists, na.rm = TRUE)), 
         legend_labels = c("small distance", "large distance"), 
         main = "Clustering heatmap"
)

```


#Probe annotation
# Load necessary libraries
```{r}
library(hgu133plus2.db)

# Annotation with "hgu133plus2.db"
anno_palmieri1 <- AnnotationDbi::select(
  hgu133plus2.db, 
  keys = featureNames(palmieri_eset_norm), 
  columns = c("SYMBOL", "GENENAME"), 
  keytype = "PROBEID")


# Remove rows with missing SYMBOL values
anno_palmieri1 <- subset(anno_palmieri1, !is.na(SYMBOL))

library(dplyr)

# Removing multiple mappings
anno_grouped <- group_by(anno_palmieri1, PROBEID)

anno_summarized <- dplyr::summarize(
  anno_grouped, 
  no_of_matches = n_distinct(SYMBOL)
)

anno_filtered <- filter(anno_summarized, no_of_matches > 1)

probe_stats <- anno_filtered
```

```{r}
# Checking number of probes to exclude
nrow(probe_stats)
```

```{r}
# Identifying probes to exclude
ids_to_exclude <- featureNames(palmieri_eset_norm) %in% probe_stats$PROBEID

# Displaying excluded probe count
table(ids_to_exclude)
```

```{r}
# Removing probes with multiple mappings
palmieri_final <- subset(palmieri_eset_norm, !ids_to_exclude)

# Ensure palmieri_final is a valid Bioconductor object
validObject(palmieri_final)
```

```{r}
# Display first few rows of palmieri_final
head(palmieri_final)
```

```{r}
fData(palmieri_final)$PROBEID <- rownames(fData(palmieri_final))

# Merge annotation data with feature data using left_join
fData(palmieri_final) <- left_join(fData(palmieri_final), anno_palmieri1, by = "PROBEID")

### restore rownames after left_join eee 
rownames(fData(palmieri_final)) <- fData(palmieri_final)$PROBEID 
validObject(palmieri_final) 
Biobase::pData(palmieri_final) 
write.csv(palmieri_final, "palmieri_final11.csv")
```

#---------------linear model----------------#
```{r}
# Load necessary libraries
library(Biobase)
library(stringr)

# Extract sample identifiers
individual <- 
  as.character(Biobase::pData(palmieri_final)$Factor.Value.disease.)

disease <- str_replace_all(Biobase::pData(palmieri_final)$Factor.Value.disease., " ", " ")

disease <- ifelse(str_detect(Biobase::pData(palmieri_final)$Factor.Value.disease., "normal"), 
                  "Normal", 
                  "Colorectal Cancer")
```


```{r}
# Create design matrix
design_palmieri <- model.matrix(~ 0 + disease)

# Rename columns
colnames(design_palmieri) <- c("CLC", "Normal")

# Assign row names
rownames(design_palmieri) <- individual

# Write to CSV
write.csv(design_palmieri, "design_matrix.csv")
```

```{r}
library(limma)

fit <- lmFit(palmieri_final, design_palmieri)

### REMEMBER: While taking contrast, you should place first those samples ###
# in which you want to see differently expressed genes #
contrast_matrix <- makeContrasts('CLC-Normal', levels = design_palmieri)

# Apply contrasts and empirical Bayes moderation
palmieri_fit <- eBayes(contrasts.fit(lmFit(palmieri_final, design_palmieri), contrast_matrix))
```

```{r}
# Extract results table
table <- topTable(palmieri_fit, number = Inf)

# Save results to CSV
write.csv(table, "top_table_final.csv")

# Exclude genes with NO symbols
table <- subset(table, !is.na(SYMBOL))

# Save the full results table (before filtering) to a CSV file
write.csv(table, "full_results_table.csv", row.names = TRUE)

# Select significantly differentially expressed genes (FDR < 0.05)
DEG_Norm_DS <- subset(table, adj.P.Val < 0.05)
# Add Condition Column (1 = Normal, 0 = Colorectal Cancer)
DEG_Norm_DS$Condition <- ifelse(DEG_Norm_DS$logFC < 0, 1, 0)
```

```{r}
# Save final results with Condition column
write.csv(DEG_Norm_DS, "Finalize_table1.csv", row.names = TRUE)

# Save final results
write.csv(DEG_Norm_DS, "Finalize_table.csv", row.names = TRUE)
```

```{r}
# Load necessary library
library(EnhancedVolcano)

# Generate volcano plot
EnhancedVolcano(
  table,
  lab = table$SYMBOL,  
  x = "logFC",
  y = "P.Value",
  ylim = c(0, -log10(10e-12)),  
  pCutoff = 0.05,  
  FCcutoff = 0.5,  
  title = "Healthy vs Colorectal Cancer"
)

# Create labels for significantly differentially expressed genes
volcano_names <- ifelse(abs(palmieri_fit$coefficients) >= 0.5, 
                        palmieri_fit$genes$SYMBOL, NA)
```

#BiocManager::install("DESeq2")

# Ensure DESeq2 is loaded
```{r}
library(DESeq2)

mydata <- read.csv("Finalize_table.csv", header = TRUE, sep = ",")

top_genes <- mydata[order(mydata$adj.P.Val, -abs(mydata$logFC)), ]

top_10_genes <- head(top_genes, 10)  # Get top 10 genes

print(top_10_genes)
```

```{r}
# table
top_10_genes_table <- top_10_genes[, c("SYMBOL", "logFC", "adj.P.Val")]  # Select required columns
colnames(top_10_genes_table) <- c("Gene Symbol", "logFC", "Adjusted P-Value")  # Rename columns

print(top_10_genes_table)  # Print formatted table

write.csv(top_10_genes_table, "Top_10_Genes.csv", row.names = FALSE)
```

# upregulated and downregulated

```{r}
# Filter significant upregulated and downregulated genes
upregulated_genes <- mydata[mydata$logFC > 0.5 & mydata$adj.P.Val < 0.05, ]  # Significant upregulated genes
downregulated_genes <- mydata[mydata$logFC < -0.5 & mydata$adj.P.Val < 0.05, ]  # Significant downregulated genes
```

```{r}
# Sort by significance (adjusted p-value) and log fold change for better ranking
upregulated_genes <- upregulated_genes[order(upregulated_genes$adj.P.Val, -upregulated_genes$logFC), ]
downregulated_genes <- downregulated_genes[order(downregulated_genes$adj.P.Val, downregulated_genes$logFC), ]

# Show top 10 upregulated and downregulated genes
top_10_upregulated <- head(upregulated_genes, 10)
top_10_downregulated <- head(downregulated_genes, 10)
```

```{r}
# Print results
print("Top 10 Upregulated Genes:")
print(top_10_upregulated[, c("SYMBOL", "logFC", "adj.P.Val")])

print("Top 10 Downregulated Genes:")
print(top_10_downregulated[, c("SYMBOL", "logFC", "adj.P.Val")])
```

```{r}
# Number of upregulated genes
num_upregulated <- nrow(upregulated_genes)
cat("Number of upregulated genes:", num_upregulated, "\n")

# Number of downregulated genes
num_downregulated <- nrow(downregulated_genes)
cat("Number of downregulated genes:", num_downregulated, "\n")


```

```{r}
total_DEGs <- num_upregulated + num_downregulated
cat("Total number of DEGs:", total_DEGs, "\n")

```

```{r}
library(EnhancedVolcano)

EnhancedVolcano(table,
    lab = table$SYMBOL,
    x = "logFC",
    y = "adj.P.Val",
    pCutoff = 0.05,
    FCcutoff = 0.5,
    title = "Volcano Plot: Cancer vs Normal",
    subtitle = "logFC > 0.5 or < -0.5; adj.P.Val < 0.05"
)

```

```{r}
# Assuming you've already filtered them
upregulated_genes <- table[table$logFC > 0.5 & table$adj.P.Val < 0.05, ]
downregulated_genes <- table[table$logFC < -0.5 & table$adj.P.Val < 0.05, ]


```
```{r}
# Add CONDITION column
upregulated_genes$CONDITION <- 1
downregulated_genes$CONDITION <- 0

# Combine both into one data frame
combined_genes <- rbind(upregulated_genes, downregulated_genes)

# Save to a single CSV file
write.csv(combined_genes, file = "combined_DEGs.csv", row.names = FALSE)

```

```{r}
library(oligo)

# Normalize using RMA
norm_data <- rma(raw_data)

# Extract expression matrix
expr_matrix <- exprs(norm_data)  # rows = genes/probes, columns = samples


```


```{r}
expr_df <- as.data.frame(t(expr_matrix))  # Now: rows = samples, columns = genes
# Check SDRF columns
colnames(pData(norm_data))
```

```{r}
expr_df$Condition <- pData(norm_data)$Factor.Value.disease.
write.csv(expr_df, "expression_data_with_labels.csv", row.names = TRUE)

```

#---------- bad code------- #
```{r}
# Read the CSV file (adjust the file path if necessary)
full_results_table <- read.csv("full_results_table.csv", header = TRUE, row.names = 1)

# Add the Condition column:
# If logFC > 0, then label as "Colorectal Cancer", otherwise "Normal"
full_results_table$Condition <- ifelse(full_results_table$logFC > 0, 
                                       "Colorectal Cancer", 
                                       "Normal")

# View the first few rows to verify the new column
head(full_results_table)

# (Optional) Write the updated table back to a CSV file
write.csv(full_results_table, "full_results_table_updated.csv", row.names = TRUE)

```

# Gene Enrichment Analysis

```{r}
library(clusterProfiler)
library(org.Hs.eg.db)

# Convert gene symbols to Entrez IDs.
gene.df <- bitr(full_results_table$SYMBOL, fromType = "SYMBOL", toType = "ENTREZID", OrgDb = org.Hs.eg.db)

# GO Enrichment Analysis
ego <- enrichGO(gene         = gene.df$ENTREZID,
                OrgDb        = org.Hs.eg.db,
                keyType      = "ENTREZID",
                ont          = "BP",           # Biological Process; can also use "MF" or "CC"
                pAdjustMethod= "BH",
                pvalueCutoff = 0.05,
                qvalueCutoff = 0.05)
barplot(ego, showCategory = 10, title = "GO BP Enrichment")



```

```{r}
# KEGG Pathway Enrichment
ekegg <- enrichKEGG(gene         = gene.df$ENTREZID,
                    organism     = 'hsa',
                    pvalueCutoff = 0.05)

barplot(ekegg, showCategory = 10, title = "KEGG Pathway Enrichment")


```

# Protein–Protein Interaction (PPI) Network Construction
```{r}
# Load the required libraries
library(STRINGdb)   # For accessing STRING database and mapping IDs
library(igraph)     # For creating and visualizing networks

# STEP 1: Initialize STRINGdb for Homo sapiens (species ID 9606)
# Set a medium confidence threshold (score >= 400)
string_db <- STRINGdb$new(version = "11", species = 9606, score_threshold = 400, input_directory = "")

# STEP 2: Map Differentially Expressed Gene (DEG) symbols to STRING IDs
# Ensure that unmapped rows are removed
mapped_DEGs <- string_db$map(Finalize_table1, "SYMBOL", removeUnmappedRows = TRUE)

# STEP 3: Retrieve protein-protein interactions for the mapped DEG STRING IDs
interactions <- string_db$get_interactions(mapped_DEGs$STRING_id)

# Display the first few rows of the interaction data for inspection
head(interactions)

# STEP 4: Create a PPI graph object using igraph
# Convert the interaction data into an undirected graph
ppi_graph <- graph_from_data_frame(d = interactions, directed = FALSE)

# STEP 5: Visualize the PPI network
# Plot the graph with basic settings: no labels, fixed vertex size
plot(ppi_graph, vertex.label = NA, vertex.size = 5, main = "PPI Network (STRING)")

```


##### new code for PPI
```{r}
library(STRINGdb)
library(org.Hs.eg.db)   # change if not human
library(tidyverse)
library(igraph)

# 1. Read in the DEG table
deg2 <- read_csv("combined_DEGs.csv")

# 2. Filter for significant DEGs (adj.P.Val < 0.05, |logFC| >= 1)
deg_filt2 <- deg2 %>%
  filter(adj.P.Val < 0.05, abs(logFC) >= 1) %>%
  select(SYMBOL, logFC, adj.P.Val)

# 3. Prepare a simple gene list for STRING mapping
deg_simple2 <- deg_filt2 %>%
  as.data.frame() %>%
  select(SYMBOL) %>%
  rename(gene = SYMBOL)

# 4. Initialize STRINGdb
string_db2 <- STRINGdb$new(
  version         = "11",
  species         = 9606,
  score_threshold = 100,
  input_directory = ""
)

# 5. Map gene symbols to STRING IDs
mapping2 <- string_db2$map(
  deg_simple2,
  "gene",  # ensure straight quotes
  removeUnmappedRows = TRUE
)

# 6. Merge mapping info with original DEG data
deg_mapped2 <- deg_filt2 %>%
  as.data.frame() %>%
  inner_join(mapping2, by = c("SYMBOL" = "gene"))

# 7. Get interaction edges between mapped genes
edges2 <- string_db2$get_interactions(deg_mapped2$STRING_id)

# 8. Remove duplicate vertices (based on STRING ID)
vertices_unique <- deg_mapped2 %>%
  transmute(
    id    = STRING_id,
    label = SYMBOL,
    logfc = logFC
  ) %>%
  distinct(id, .keep_all = TRUE)

# 9. Create igraph object from interaction data
g2 <- graph_from_data_frame(
  d = edges2,
  vertices = vertices_unique,
  directed = FALSE
)
```

```{r}
# 10. Add color and size based on logFC
library(scales)  # for rescale()

V(g2)$color <- ifelse(V(g2)$logfc > 0, "firebrick", "dodgerblue")
V(g2)$size  <- rescale(abs(V(g2)$logfc), to = c(5, 15))

# 11. Plot (optional)
plot(g2,
     vertex.label = V(g2)$label,
     vertex.label.cex = 0.7,
     main = "STRING PPI Network of Filtered DEGs")

```

```{r}
library(igraph)
library(dplyr)

# Compute degree for g2
deg_cent2 <- degree(g2, mode = "all")

# Extract vertex metadata from g2
vertex_df2 <- data.frame(
  name  = V(g2)$name,
  label = V(g2)$label
)

# Join degree with vertex info
hub_df2 <- hub_df2 %>%
  select(Gene = label, Degree = degree) %>%
  arrange(desc(Degree))

# View top 10 hubs
head(hub_df2, 10)


```

```{r}
library(igraph)
library(dplyr)

# 1. Compute centrality measures
deg_cent   <- degree(g2, mode = "all")
betw_cent  <- betweenness(g2)
close_cent <- closeness(g2)

# 2. Create a vertex info table
vertex_info <- data.frame(
  STRING_id = V(g2)$name,
  label     = V(g2)$label
)

# 3. Combine centrality with gene info, drop STRING_id
centrality_df <- data.frame(
  STRING_id   = names(deg_cent),
  degree      = deg_cent,
  betweenness = betw_cent,
  closeness   = close_cent
) %>%
  left_join(vertex_info, by = "STRING_id") %>%
  select(Gene = label, degree, betweenness, closeness)

# 4. Top 10 nodes by betweenness centrality
centrality_df %>%
  arrange(desc(betweenness)) %>%
  head(10)


```

```{r}
# Assuming your hub_df2 has the columns: STRING_id, degree, label
top_hubs2 <- hub_df2 %>%
  filter(degree > 0) %>%  # Keep only nodes with at least one connection
  arrange(desc(degree))   # Order by degree in descending order

print(top_hubs2)

```

```{r}
# Get the STRING IDs of top hubs
hub_ids2 <- top_hubs2$STRING_id

# Create a subgraph containing the hubs (and any edges between them) using g2
sub_g2 <- induced_subgraph(g2, vids = hub_ids2)

# Plot the subgraph
plot(
  sub_g2,
  vertex.label = V(sub_g2)$label,
  vertex.color = ifelse(V(sub_g2)$logfc > 0, "firebrick", "dodgerblue"),
  vertex.size  = scales::rescale(abs(V(sub_g2)$logfc), to = c(5,15)),
  edge.width   = E(sub_g2)$combined_score / 200,
  main         = "Subnetwork of Hub Proteins"
)

```

```{r}
library(clusterProfiler)
library(org.Hs.eg.db)

# 1. Take the hub gene symbols
hub_symbols2 <- top_hubs2$label

# 2. Map SYMBOL → ENTREZID
entrez_map_hubs2 <- bitr(
  hub_symbols2,
  fromType = "SYMBOL",
  toType   = "ENTREZID",
  OrgDb    = org.Hs.eg.db,
  drop     = TRUE
)

# Inspect mapping
print(entrez_map_hubs2)
```

```{r}
library(clusterProfiler)
library(org.Hs.eg.db)

# 1. GO BP enrichment for hub genes using their mapped ENTREZ IDs
ego_hubs2 <- enrichGO(
  gene          = entrez_map_hubs2$ENTREZID,  # Ensure this vector is non-empty
  OrgDb         = org.Hs.eg.db,
  keyType       = "ENTREZID",
  ont           = "BP",                     # Investigate Biological Processes
  pAdjustMethod = "BH",
  pvalueCutoff  = 0.1,
  qvalueCutoff  = 0.3
)

# 2. View the top 5 enriched GO terms, if available
head_df <- head(as.data.frame(ego_hubs2), 5)
print(head_df)

# 3. Plot a barplot for the top 5 GO BP terms
barplot(ego_hubs2, showCategory = 5, title = "GO BP Enrichment of Hub Proteins")

```


```{r}
# 1. Load libraries
library(clusterProfiler)
library(org.Hs.eg.db)   # human gene annotations
library(tidyverse)

# 2. Define your hub symbols (ensuring uniqueness)
hub_symbols2.1 <- unique(top_hubs2$label)
cat("Number of unique hub symbols:", length(hub_symbols2.1), "\n")
print(head(hub_symbols2.1))

# 3. Map SYMBOL → ENTREZID using bitr
entrez_map_hubs2.1 <- bitr(
  hub_symbols2.1,
  fromType = "SYMBOL",
  toType   = "ENTREZID",
  OrgDb    = org.Hs.eg.db,
  drop     = TRUE
)
cat("Number of hub symbols mapped to ENTREZID:", nrow(entrez_map_hubs2.1), "\n")
print(head(entrez_map_hubs2.1))

# 4. Prepare vector of ENTREZIDs for enrichment analysis
hub_entrez2.1 <- entrez_map_hubs2.1$ENTREZID

# 5. Run KEGG enrichment analysis for human (organism = "hsa")
# Run KEGG enrichment analysis with relaxed cutoffs
kegg_res2 <- enrichKEGG(
  gene         = hub_entrez2.1,
  organism     = "hsa",
  keyType      = "ncbi-geneid",
  pvalueCutoff = 0.1,  # relaxed from 0.05 to 0.1
  qvalueCutoff = 0.3   # relaxed from 0.2 to 0.3
)


# 6. Inspect KEGG enrichment results
kegg_df2 <- as.data.frame(kegg_res2)
if(nrow(kegg_df2) == 0){
  message("No KEGG pathway enrichment found for the given hub genes. Consider adjusting the cutoff thresholds or reviewing your gene list.")
} else {
  print(head(kegg_df2, 10))
  
  # 7. Ensure proper encoding for the 'Description' field
  kegg_res2@result$Description <- sapply(
    as.character(kegg_res2@result$Description),
    function(x) iconv(x, from = "", to = "UTF-8", sub = "")
  )
  # Update the dataframe after encoding conversion
  kegg_df2 <- as.data.frame(kegg_res2)
  
  # 8. Create a dotplot without the title parameter first, then add the title using ggplot2
  dp <- barplot(
    kegg_res2,
    showCategory = min(8, nrow(kegg_df2))
  )
  
  # Add title via ggtitle
  dp <- dp + ggtitle("KEGG Pathway Enrichment of Hub Proteins")
  
  # Display the plot
  print(dp)
}

```

